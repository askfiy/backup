# Rest Framework


## 简介

Rest Framework 是一种前后端分离项目中接口的设计规范，其本身与任何框架无关，是一种软件架构风格，全称为 Representational State Transfer。

Rest Framework 最显著的特点就是将一切数据看成资源，同时对不同的请求方式进行责任划分。

这种结构理念也被称为面向资源架构。

## 前后端分离

前后端分离是目前比较火热的一种架构方案，下面是前后端分离架构与前后端混合架构的模型对比。

前后端混合开发时，浏览器页面由后端书写，页面上的数据由模板渲染而来：

```
┌──────────────┐                     ┌──────────────────────────────────────────┐
│              │                     │                                          │
│              │                     │  ┌────────────────┐    ┌──────────────┐  │
│              │                     │  │                │    │              │  │
│              │                     │  │                │    │              │  │
│              │────请求动态页面────►│  │                │    │              │  │
│              │                     │  │   查询数据库   │    │              │  │
│   browser    │                     │  │    渲染模板    │◄──►│    数据库    │  │
│              │◄──返回 HTML 数据────┤  │ 或者资源重定向 │    │              │  │
│              │                     │  │                │    │              │  │
│              │                     │  │                │    │              │  │
│              │                     │  │                │    │              │  │
│              │                     │  │                │    │              │  │
│              │                     │  └────────────────┘    └──────────────┘  │
│              │                     │                                          │
└──────────────┘                     └──────────────────────────────────────────┘
```

前后端分离开发时，后端服务器只返回页面需要的数据，不再承担模板的渲染工作：

```
┌──────────────┐                     ┌──────────────────────────────────────────┐
│              │                     │              静态文件服务器              │
│              │◄请求静态页面并返回─►│              HTML、CSS、JS               │
│              │                     │                                          │
│              │                     └──────────────────────────────────────────┘
│   browser    │
│              │
│              │                     ┌──────────────────────────────────────────┐
│┌────────────┐│                     │                                          │
││运行 Js 请求││                     │  ┌────────────────┐      ┌────────────┐  │
││ 后端数据并 ││◄请求并返回填充数据─►│  │                │      │            │  │
││  填充页面  ││                     │  │   应用服务器   │      │            │  │
│└────────────┘│                     │  │    提供接口    │      │            │  │
└──────────────┘                     │  │  根据请求方式  │◄───► │   数据库   │  │
                                     │  │    返回数据    │      │            │  │
┌──────────────┐                     │  │ 不负责页面处理 │      │            │  │
│              │                     │  │                │      │            │  │
│     app      │◄请求并返回填充数据─►│  └────────────────┘      └────────────┘  │
│              │                     │                                          │
└──────────────┘                     └──────────────────────────────────────────┘
```

## API 设计

RESTFUL API 设计规范如下。

1. 通信协议上应该采用 HTTPS 协议以确保数据安全

```
HTTP 端口号是 80, HTTPS 的端口号是 443。
HTTP 是明文传输, 安全性较差、HTTPS 是密文传输，安全性较高。
HTTP 响应速度比 HTTPS 更快，因为 HTTPS 需要 SSL 握手，一共要交换 12 个包，HTTP 只需要交换 3 个包（三次握手）。
```

2. API 接口 url 应当具有一定的辨识度，如下示例：

```
https://api.example.com/
https://example.org/api/
```

3. API 接口 url 应当放入版本号，如下示例：

```
https://api.example.com/v1/
https://api.example.com/v2/
```

4. API 接口 url 请求中只能含有动词，不能含有名词且支持复数。此外，所用名词应当与数据库中的表名对应，如下示例：

```
https://api.example.com/v1/book/         # 规范
https//api.example.com/v1/get_book/      # 不规范
```

5. 由于 API 接口的 url 中不应当含有动词，所以可以根据不同的资源请求方式来对处理逻辑进行划分，如下所示：

```
GET    （SELECT） ： 向服务器请求获取资源
POST   （CREATE） ： 向服务器请求新建资源
PUT    （UPDATE） ： 向服务器请求更新资源（需提供客户端改变后的完整资源）
PATCH  （UPDATE） ： 向服务器请求更新资源（仅提供客户端改变后的资源属性）
DELETE （DELETE） ： 向服务器请求删除资源
```

6. 如果客户端需要获取的资源数据较多，服务端不可能完全将它们返回给客户端，此时 API 接口应当提供参数以过滤返回结果，如下所示：

```
limit   ： 指定返回记录的数量
    - GET /book?limit=10
offset  ： 指定返回记录的开始位置
    - GET /book?offset=10
page    ： 指定从第几页开始返回记录
    - GET /book?page=10
per_page： 指定获取返回记录中每页的数量
    - GET /book?page=10&per_page=10
order   ： 指定排序规则
    - GET /book?limit=10&order=asc
sortby  ： 指定排序条件
    - GET /book?limit=10&order=asc&sortby=date
```

7. 服务器应当向客户端返回本次操作的结果状态码以及提示信息，如下示例：

```
- [n] 表示请求方式

200 ok [GET]
    服务器成功执行客户端请求（该操作是幂等的）
201 create [POST/PUT/PATCH]
    服务器成功执行客户端的新建资源、更新资源请求
202 accepted [*]
    服务器成功将客户端请求加入任务队列
204 no content [DELETE]
    服务器成功执行客户端的删除资源请求

400 invalid request [POST/PUT/PATCH]
    服务器并未成功执行客户端的新建资源、更新资源请求，客户端发出的请求指令有误（该操作是幂等的）
401 unauthorized [*]
    服务器并未成功执行客户端的请求，因为客户端没有权限，这可能是令牌、用户名、密码错误所导致的
403 forbidden [*]
    服务器并未成功执行客户端的请求，客户端权限验证尽管已经通过，但该操作是禁止的（与 401 相对）
404 not found [*]
    服务器并未成功执行客户端的请求，因为客户端所请求的资源是不存在的（该操作是幂等的）
406 not acceptable [GET]
    服务器并未成功执行客户端的请求，因为客户端所请求的格式是不被支持的（如客户端请求的是 XML 格式数据，但服务端只提供了 JSON 格式的数据）
410 gone [get]
    服务器并未成功执行客户端的请求，因为客户端所请求的资源被永久删除且不会再恢复了
422 unprocesable entity [POST/PUT/PATCH]
    服务器并未成功执行客户端的新建资源、更新资源请求，因为服务端在处理请求时发生了验证错误

500 internal server error [*]
    服务器并未成功执行客户端的请求，因为服务器内部发生了错误，此时客户端将无法判断发出的请求是否有效
```

8. 服务器应当对返回内容进行详细说明，如返回状态码是 4xx，则应当在返回内容中加入 error 错误描述信息，如下所示：

```
{
    data    : null,
    message : "",
    error   : "Invalid API Key"
}
```

9. 服务器对不同 API 的请求结果所返回的对象应该是不同的，如下所示：

```
GET /book/     ： 返回包含所有资源对象的数组
GET /book/1    ： 返回一个资源对象
POST /book     ： 返回新建立的完整资源对象
PUT /book      ： 返回修改完成的完整资源对象
PATCH /book    ： 返回修改完成的完整资源对象
DELETE /book/1 ： 返回空文档（也可返回一个操作码）
```

10. 服务器可以在返回的信息中添加链接，如下所示：

```
{
    link: {
        "href": "https://api.example.com/zoos",
    }
}
```
